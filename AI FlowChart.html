<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Flujo Interactivo con IA</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #50e3c2;
            --background-color: #f4f7f6;
            --text-color: #333;
            --node-border: #ccc;
            --node-selected-border: var(--primary-color);
            --connection-color: #666;
            --connection-selected-color: var(--primary-color);
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            --danger-color: #e74c3c;
            --danger-hover-color: #c0392b;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }

        .controls button, .modal button, .sidebar button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .controls button:hover, .modal button:hover, .sidebar button:hover {
            background-color: #45c9b0;
        }
        .controls button:active, .modal button:active, .sidebar button:active {
            transform: scale(0.98);
        }
        .sidebar button.danger {
            background-color: var(--danger-color);
        }
        .sidebar button.danger:hover {
            background-color: var(--danger-hover-color);
        }

        .controls button svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            position: relative; 
            overflow: hidden;
        }

        .flowchart-container {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            background-image:
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #flowchart-svg {
            display: block; 
        }

        .node-shape {
            stroke-width: 1.5;
            transition: filter 0.2s ease, stroke 0.2s ease; 
        }
        .node-shape.selected {
            stroke-width: 3;
            filter: drop-shadow(0px 0px 5px var(--node-selected-border));
        }
        .node-text {
            font-family: var(--font-family); 
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none; 
            user-select: none;
        }
        .connection-point {
            fill: red;
            stroke: darkred;
            stroke-width: 1;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.3s ease, r 0.2s ease, fill 0.2s ease;
        }
        .node:hover .connection-point, .connection-point.visible, .connection-point.highlight {
            opacity: 1;
        }
        .connection-point.highlight {
            fill: var(--secondary-color);
            stroke: var(--primary-color);
            r: calc(var(--cp-radius, 8px) * 1.3);
        }


        .connection-line {
            stroke-width: 2;
            fill: none;
            transition: stroke 0.2s ease;
        }
        .connection-line.selected {
            stroke-width: 4;
        }
        .connection-label {
            font-family: var(--font-family); 
            font-size: 10px;
            fill: blue;
            text-anchor: middle;
            user-select: none;
        }
        .connection-handle {
            fill: var(--primary-color);
            stroke: white;
            stroke-width: 1.5;
            cursor: move; 
            r: 6px;
        }
       
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s 0.3s;
        }
        .modal.visible {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
        }
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            width: 90%;
            max-width: 500px;
            text-align: center;
        }
        .modal-content h2 {
            margin-top: 0;
            color: var(--primary-color);
        }
        .modal-content label {
            display: block;
            margin-bottom: 8px;
            text-align: left;
            font-weight: bold;
        }
        .modal-content input[type="text"], 
        .modal-content textarea {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }
        .modal-content textarea {
            min-height: 100px;
            resize: vertical;
        }

        #context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 5px 0;
            z-index: 1001;
            min-width: 180px;
        }
        #context-menu div {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #context-menu div:hover {
            background-color: #f0f0f0;
        }
        
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--secondary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sidebar {
            width: 280px;
            background-color: #fff;
            border-left: 1px solid #ddd;
            padding: 20px;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
            transform: translateX(100%);
            z-index: 900;
        }
        .sidebar.visible {
            transform: translateX(0);
        }
        .sidebar h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            font-size: 1.2em;
        }
        .sidebar label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .sidebar input[type="text"],
        .sidebar textarea {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
            box-sizing: border-box;
        }
        .sidebar textarea {
            min-height: 80px;
            resize: vertical;
        }
        .sidebar input[type="color"] {
            width: calc(100% - 22px);
            height: 40px;
            padding: 0;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
         .sidebar .id-display {
            font-size: 0.8em;
            color: #777;
            margin-bottom: 10px;
            word-break: break-all;
        }
        #recent-colors-container {
            margin-top: 5px;
            margin-bottom: 10px;
            display: flex; /* Para alinear los swatches */
            flex-wrap: wrap; /* Para que pasen a la siguiente línea si no caben */
            gap: 5px; /* Espacio entre swatches */
        }
        .recent-color-swatch {
            display: inline-block;
            width: 24px; /* Aumentado ligeramente para mejor click */
            height: 24px; /* Aumentado ligeramente */
            border: 1px solid #ccc;
            border-radius: 4px; /* Más redondeado */
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        .recent-color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
        }

    </style>
</head>
<body>

    <div class="header">
        <h1>Diagrama de Flujo Interactivo</h1>
        <div class="controls">
            <button id="generate-ai-btn">
                <svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,6H13V11L17,13L16.25,14.25L11.5,11.5V6M12,18A6,6 0 0,1 6,12H8A4,4 0 0,0 12,16A4,4 0 0,0 16,12H18A6,6 0 0,1 12,18Z" /></svg>
                Generar con IA
            </button>
            <button id="add-connection-btn">
                 <svg viewBox="0 0 24 24"><path d="M22 12L18 8V11H10V6L12 3L4 12L12 21L10 18V13H18V16L22 12Z" /></svg>
                Conectar Nodos
            </button>
            <button id="export-svg-btn">
                <svg viewBox="0 0 24 24"><path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" /></svg>
                Exportar SVG
            </button>
            <button id="clear-btn">
                <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                Limpiar
            </button>
            <button id="set-api-key-btn">
                <svg viewBox="0 0 24 24"><path d="M12,2A4,4 0 0,0 8,6C8,7.58 9.06,8.91 10.5,9.54L4.88,15.12L6.29,16.54L12,10.83L17.71,16.54L19.12,15.12L13.5,9.53C14.94,8.91 16,7.58 16,6A4,4 0 0,0 12,2M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z" /></svg>
                API Key
            </button>
        </div>
    </div>

    <div class="main-content">
        <div class="flowchart-container" id="flowchart-container">
            <svg id="flowchart-svg" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto-start-reverse">
                        <polygon points="0 0, 10 3.5, 0 7" style="fill: var(--connection-color);" />
                    </marker>
                     <marker id="arrowhead-selected" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto-start-reverse">
                        <polygon points="0 0, 10 3.5, 0 7" style="fill: var(--connection-selected-color);" />
                    </marker>
                </defs>
                <g id="nodes-group"></g> <!-- NODOS PRIMERO -->
                <g id="connections-group"></g> <!-- CONEXIONES DESPUÉS -->
                <path id="connection-preview-line" stroke="gray" stroke-width="2" stroke-dasharray="5,5" fill="none" visibility="hidden" marker-end="url(#arrowhead)"/>
            </svg>
        </div>
        <div id="edit-panel" class="sidebar">
            <h3>Editar Elemento</h3>
            <div id="edit-panel-node-content" style="display:none;">
                <label for="panel-node-text">Texto:</label>
                <textarea id="panel-node-text"></textarea>
                <label for="panel-node-color">Color:</label>
                <input type="color" id="panel-node-color">
                <div id="recent-colors-container">
                    <!-- Los colores recientes se insertarán aquí por JS -->
                </div>
                <label>ID del Nodo:</label>
                <p id="panel-node-id" class="id-display"></p>
            </div>
            <div id="edit-panel-conn-content" style="display:none;">
                 <label for="panel-conn-label">Etiqueta de Conexión:</label>
                 <input type="text" id="panel-conn-label"/>
                 <label>ID de Conexión:</label>
                 <p id="panel-conn-id" class="id-display"></p>
            </div>
            <button id="panel-delete-btn" class="danger">Eliminar Elemento</button>
        </div>
    </div>
    
    <div id="api-key-modal" class="modal">
        <div class="modal-content">
            <h2>Configurar API Key de Gemini</h2>
            <p>Por favor, introduce tu API Key para Google Gemini.</p>
            <label for="api-key-input">API Key:</label>
            <input type="text" id="api-key-input" placeholder="AIzaSy..."/>
            <button id="save-api-key-btn">Guardar</button>
            <button id="cancel-api-key-btn" style="background-color: #aaa;">Cancelar</button>
        </div>
    </div>

    <div id="ai-prompt-modal" class="modal">
        <div class="modal-content">
            <h2>Generar Diagrama con IA</h2>
            <p>Describe el proceso que quieres convertir en diagrama:</p>
            <textarea id="ai-prompt-input" placeholder="Ej: Iniciar sesión, verificar credenciales, si es válido mostrar dashboard, si no mostrar error."></textarea>
            <div id="ai-loader" class="loader" style="display: none;"></div>
            <button id="submit-ai-prompt-btn">Generar</button>
            <button id="cancel-ai-prompt-btn" style="background-color: #aaa;">Cancelar</button>
        </div>
    </div>
    
    <div id="context-menu" style="display:none;"></div>


<script>
    const SVG_NS = "http://www.w3.org/2000/svg";
    const flowchartSVG = document.getElementById('flowchart-svg');
    const nodesGroup = document.getElementById('nodes-group');
    const connectionsGroup = document.getElementById('connections-group');
    const connectionPreviewLine = document.getElementById('connection-preview-line');
    
    const apiKeyModal = document.getElementById('api-key-modal');
    const aiPromptModal = document.getElementById('ai-prompt-modal');
    const contextMenu = document.getElementById('context-menu');

    const editPanel = document.getElementById('edit-panel');
    const editPanelNodeContent = document.getElementById('edit-panel-node-content');
    const panelNodeText = document.getElementById('panel-node-text');
    const panelNodeColor = document.getElementById('panel-node-color');
    const panelNodeId = document.getElementById('panel-node-id');
    const editPanelConnContent = document.getElementById('edit-panel-conn-content');
    const panelConnLabel = document.getElementById('panel-conn-label');
    const panelConnId = document.getElementById('panel-conn-id');
    const panelDeleteBtn = document.getElementById('panel-delete-btn');
    const recentColorsContainer = document.getElementById('recent-colors-container');


    let nodes = [];
    let connections = [];
    let nextNodeIdCounter = 1;
    let selectedElement = null; 
    let draggingNode = false;
    let dragOffsetX, dragOffsetY;
    let connectionMode = false;
    let firstConnectionNode = null;
    let firstConnectionPointName = null; 
    let geminiApiKey = localStorage.getItem('geminiApiKey');
    let draggingConnectionHandle = null;
    let recentColors = JSON.parse(localStorage.getItem('recentFlowchartColors')) || [];
    const MAX_RECENT_COLORS = 7;


    const NODE_WIDTH = 120;
    const NODE_HEIGHT = 60;
    const CONNECTION_POINT_RADIUS = 8;
    document.documentElement.style.setProperty('--cp-radius', CONNECTION_POINT_RADIUS + 'px');
    const SVG_PADDING = 100; 

    function getCssVariable(variableName) {
        return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
    }

    // --- Recent Colors Management ---
    function addRecentColor(hexColor) {
        if (!hexColor.match(/^#[0-9a-fA-F]{6}$/)) return; // Validate hex

        const index = recentColors.indexOf(hexColor);
        if (index > -1) { // Move to front if exists
            recentColors.splice(index, 1);
        }
        recentColors.unshift(hexColor); // Add to the beginning
        if (recentColors.length > MAX_RECENT_COLORS) {
            recentColors.length = MAX_RECENT_COLORS; // Limit size
        }
        localStorage.setItem('recentFlowchartColors', JSON.stringify(recentColors));
        renderRecentColors();
    }

    function renderRecentColors() {
        recentColorsContainer.innerHTML = '';
        if (recentColors.length > 0) {
            const label = document.createElement('label');
            label.textContent = "Recientes:";
            label.style.width = "100%"; // Ocupa toda la línea
            label.style.marginBottom = "3px";
            recentColorsContainer.appendChild(label);
        }
        recentColors.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'recent-color-swatch';
            swatch.style.backgroundColor = color;
            swatch.title = color;
            swatch.addEventListener('click', () => {
                if (selectedElement instanceof FlowchartNode) {
                    selectedElement.color = color;
                    panelNodeColor.value = color; // Sync color picker
                    redrawAll();
                    // No es necesario llamar a addRecentColor aquí de nuevo, ya está.
                }
            });
            recentColorsContainer.appendChild(swatch);
        });
    }


    document.getElementById('set-api-key-btn').addEventListener('click', () => {
        apiKeyModal.classList.add('visible');
        document.getElementById('api-key-input').value = geminiApiKey || '';
    });
    document.getElementById('save-api-key-btn').addEventListener('click', () => {
        geminiApiKey = document.getElementById('api-key-input').value.trim();
        if (geminiApiKey) {
            localStorage.setItem('geminiApiKey', geminiApiKey);
            apiKeyModal.classList.remove('visible');
            alert('API Key guardada.');
        } else {
            alert('Por favor, introduce una API Key.');
        }
    });
    document.getElementById('cancel-api-key-btn').addEventListener('click', () => apiKeyModal.classList.remove('visible'));

    function checkApiKey() {
        if (!geminiApiKey) {
            apiKeyModal.classList.add('visible');
            return false;
        }
        return true;
    }

    class FlowchartNode {
        constructor(id, text, type, x, y, color = "#add8e6") {
            this.id = id; this.text = text; this.type = type; 
            this.x = x; this.y = y; 
            this.width = NODE_WIDTH; this.height = NODE_HEIGHT;
            this.color = color; this.selected = false;
        }
        getConnectionPoints() {
            return {
                'top': { x: this.x, y: this.y - this.height / 2 },
                'bottom': { x: this.x, y: this.y + this.height / 2 },
                'left': { x: this.x - this.width / 2, y: this.y },
                'right': { x: this.x + this.width / 2, y: this.y }
            };
        }
    }

    class FlowchartConnection {
        constructor(id, fromNodeId, toNodeId, fromPoint = 'bottom', toPoint = 'top', label = "") {
            this.id = id || `conn-${Date.now()}-${Math.random().toString(36).substring(2,7)}`; 
            this.fromNodeId = fromNodeId; this.toNodeId = toNodeId;
            this.fromPoint = fromPoint; this.toPoint = toPoint;
            this.label = label; this.selected = false;
        }
    }
    
    function findNodeById(id) { return nodes.find(n => n.id === id); }
    function findConnectionById(id) { return connections.find(c => c.id === id); }

    function redrawAll() {
        // Clear groups
        while (nodesGroup.firstChild) nodesGroup.removeChild(nodesGroup.firstChild);
        while (connectionsGroup.firstChild) connectionsGroup.removeChild(connectionsGroup.firstChild);
    
        // Draw nodes first (so they are "behind")
        nodes.forEach(drawNode);
        // Then draw connections (so they are "on top")
        connections.forEach(drawConnection);
    
        updateSelectionVisuals(); 
        updateSvgDimensions(); 
        updateEditPanel();
        // Render recent colors if panel is visible for a node
        if (editPanel.classList.contains('visible') && selectedElement instanceof FlowchartNode) {
            renderRecentColors();
        }
    }

    function updateSvgDimensions() {
        const container = flowchartSVG.parentElement;
        if (!container) return;
        if (nodes.length === 0) {
            flowchartSVG.setAttribute('width', container.clientWidth || '100%');
            flowchartSVG.setAttribute('height', container.clientHeight || '100%');
            flowchartSVG.removeAttribute('viewBox'); return;
        }
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        nodes.forEach(node => {
            minX = Math.min(minX, node.x - node.width / 2); maxX = Math.max(maxX, node.x + node.width / 2);
            minY = Math.min(minY, node.y - node.height / 2); maxY = Math.max(maxY, node.y + node.height / 2);
        });
        minX = isFinite(minX) ? minX : 0; minY = isFinite(minY) ? minY : 0;
        maxX = isFinite(maxX) ? maxX : NODE_WIDTH; maxY = isFinite(maxY) ? maxY : NODE_HEIGHT;
        const svgActualWidth = Math.max(maxX + SVG_PADDING, container.clientWidth);
        const svgActualHeight = Math.max(maxY + SVG_PADDING, container.clientHeight);
        flowchartSVG.setAttribute('width', svgActualWidth);
        flowchartSVG.setAttribute('height', svgActualHeight);
    }

    function drawNode(node) {
        const group = document.createElementNS(SVG_NS, 'g');
        group.setAttribute('id', `node-${node.id}`); group.setAttribute('class', 'node');
        group.setAttribute('transform', `translate(${node.x - node.width/2}, ${node.y - node.height/2})`);
        let shape;
        if (node.type === 'decision') {
            shape = document.createElementNS(SVG_NS, 'polygon');
            const w = node.width, h = node.height;
            shape.setAttribute('points', `${w/2},0 ${w},${h/2} ${w/2},${h} 0,${h/2}`);
        } else if (node.type === 'start' || node.type === 'end') {
            shape = document.createElementNS(SVG_NS, 'ellipse');
            shape.setAttribute('cx', node.width / 2); shape.setAttribute('cy', node.height / 2);
            shape.setAttribute('rx', node.width / 2); shape.setAttribute('ry', node.height / 2);
        } else { 
            shape = document.createElementNS(SVG_NS, 'rect');
            shape.setAttribute('width', node.width); shape.setAttribute('height', node.height);
            shape.setAttribute('rx', 5); 
        }
        shape.setAttribute('fill', node.color); shape.setAttribute('stroke', getCssVariable('--node-border')); 
        shape.setAttribute('class', 'node-shape'); shape.dataset.nodeId = node.id;
        group.appendChild(shape);
        const text = document.createElementNS(SVG_NS, 'text');
        text.setAttribute('x', node.width / 2); text.setAttribute('y', node.height / 2);
        text.setAttribute('class', 'node-text'); text.textContent = node.text;
        group.appendChild(text);
        const pointsData = node.getConnectionPoints();
        for (const pointName in pointsData) {
            const cp = document.createElementNS(SVG_NS, 'circle');
            const relativeX = pointsData[pointName].x - node.x + node.width/2;
            const relativeY = pointsData[pointName].y - node.y + node.height/2;
            cp.setAttribute('cx', relativeX); cp.setAttribute('cy', relativeY);
            cp.setAttribute('r', CONNECTION_POINT_RADIUS); cp.setAttribute('class', 'connection-point');
            cp.dataset.nodeId = node.id; cp.dataset.pointName = pointName;
            group.appendChild(cp);
        }
        nodesGroup.appendChild(group);
    }

    function drawConnection(conn) {
        const fromNode = findNodeById(conn.fromNodeId); const toNode = findNodeById(conn.toNodeId);
        if (!fromNode || !toNode) return;
        const p1 = fromNode.getConnectionPoints()[conn.fromPoint];
        const p2 = toNode.getConnectionPoints()[conn.toPoint];
        const path = document.createElementNS(SVG_NS, 'path');
        const pathData = getPathData(p1, p2, conn.fromPoint, conn.toPoint);
        path.setAttribute('d', pathData); path.setAttribute('class', 'connection-line'); 
        path.dataset.connectionId = conn.id; connectionsGroup.appendChild(path);
        if (conn.label) {
            const labelText = document.createElementNS(SVG_NS, 'text');
            const { controlX, controlY } = getPathControlPoints(p1, p2, conn.fromPoint, conn.toPoint);
            let labelX = controlX; let labelY = controlY - 10;
            if (Math.sqrt(Math.pow(controlX - (p1.x + p2.x)/2, 2) + Math.pow(controlY - (p1.y + p2.y)/2, 2)) > 50 ) {
                 labelX = (p1.x + p2.x) / 2; labelY = (p1.y + p2.y) / 2 - 10;
            }
            labelText.setAttribute('x', labelX); labelText.setAttribute('y', labelY);
            labelText.setAttribute('class', 'connection-label'); labelText.textContent = conn.label;
            labelText.dataset.connectionId = conn.id; connectionsGroup.appendChild(labelText);
        }
        if (conn.selected) {
            const startHandle = document.createElementNS(SVG_NS, 'circle');
            startHandle.setAttribute('cx', p1.x); startHandle.setAttribute('cy', p1.y);
            startHandle.setAttribute('class', 'connection-handle');
            startHandle.dataset.connectionId = conn.id; startHandle.dataset.handleType = 'from';
            connectionsGroup.appendChild(startHandle);
            const endHandle = document.createElementNS(SVG_NS, 'circle');
            endHandle.setAttribute('cx', p2.x); endHandle.setAttribute('cy', p2.y);
            endHandle.setAttribute('class', 'connection-handle');
            endHandle.dataset.connectionId = conn.id; endHandle.dataset.handleType = 'to';
            connectionsGroup.appendChild(endHandle);
        }
    }
    
    function getPathControlPoints(p1, p2, fromPointType, toPointType) {
        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
        let controlX = (p1.x + p2.x) / 2; let controlY = (p1.y + p2.y) / 2;
        const curveIntensity = 0.3;
        if (fromPointType === 'bottom' || fromPointType === 'top') {
            controlX += dx * curveIntensity;
            if (fromPointType === 'bottom') controlY += Math.abs(dy) * curveIntensity * (dy === 0 ? 1 : Math.sign(dy)) + (dy===0?NODE_HEIGHT/2:0);
            else controlY -= Math.abs(dy) * curveIntensity * (dy === 0 ? 1 : Math.sign(dy)) - (dy===0?NODE_HEIGHT/2:0);
        } else {
            controlY += dy * curveIntensity;
            if (fromPointType === 'right') controlX += Math.abs(dx) * curveIntensity * (dx === 0 ? 1 : Math.sign(dx)) + (dx===0?NODE_WIDTH/2:0);
            else controlX -= Math.abs(dx) * curveIntensity * (dx === 0 ? 1 : Math.sign(dx)) - (dx===0?NODE_WIDTH/2:0);
        }
        if(controlX === p2.x && controlY === p2.y) controlY += 20;
        if(controlX === p1.x && controlY === p1.y) controlY -= 20;
        return { controlX, controlY };
    }

    function getPathData(p1, p2, fromPointType, toPointType) {
        const { controlX, controlY } = getPathControlPoints(p1, p2, fromPointType, toPointType);
        return `M ${p1.x},${p1.y} Q ${controlX},${controlY} ${p2.x},${p2.y}`;
    }

    function updateSelectionVisuals() {
        document.querySelectorAll('.node-shape').forEach(s => {
            const node = findNodeById(s.dataset.nodeId);
            s.classList.toggle('selected', node && node.selected);
            s.style.stroke = (node && node.selected) ? getCssVariable('--node-selected-border') : getCssVariable('--node-border');
        });
        document.querySelectorAll('.connection-line').forEach(l => {
            const conn = findConnectionById(l.dataset.connectionId);
            l.classList.toggle('selected', conn && conn.selected);
            l.style.stroke = (conn && conn.selected) ? getCssVariable('--connection-selected-color') : getCssVariable('--connection-color');
            l.setAttribute('marker-end', (conn && conn.selected) ? 'url(#arrowhead-selected)' : 'url(#arrowhead)');
        });
        document.querySelectorAll('.connection-label').forEach(l => {
             const conn = findConnectionById(l.dataset.connectionId);
             l.style.fontWeight = (conn && conn.selected) ? 'bold' : 'normal';
        });
    }

    flowchartSVG.addEventListener('mousedown', (e) => {
        hideContextMenu();
        const target = e.target;
        const { x: svgX, y: svgY } = getSVGCoordinates(e);

        if (connectionMode && target.classList.contains('connection-point')) {
            const nodeId = target.dataset.nodeId;
            const pointName = target.dataset.pointName;
            const nodeInstance = findNodeById(nodeId);
            if (!nodeInstance) return;
            if (!firstConnectionNode) {
                firstConnectionNode = nodeInstance; firstConnectionPointName = pointName;
                const absPoint = nodeInstance.getConnectionPoints()[pointName];
                connectionPreviewLine.setAttribute('d', `M ${absPoint.x},${absPoint.y} Q ${absPoint.x},${absPoint.y} ${absPoint.x},${absPoint.y}`);
                connectionPreviewLine.setAttribute('visibility', 'visible');
            } else {
                if (nodeInstance.id !== firstConnectionNode.id || (nodeInstance.id === firstConnectionNode.id && pointName !== firstConnectionPointName)) {
                    const newConn = new FlowchartConnection( null, firstConnectionNode.id, nodeInstance.id, firstConnectionPointName, pointName );
                    connections.push(newConn);
                    resetConnectionMode();
                }
            }
            updateSelectionVisuals(); return; 
        }

        let elementWasInteractedWith = false;
        if (target.classList.contains('node-shape')) {
            deselectAll(); selectedElement = findNodeById(target.dataset.nodeId);
            if (selectedElement) {
                selectedElement.selected = true; draggingNode = true;
                dragOffsetX = svgX - selectedElement.x + selectedElement.width/2; 
                dragOffsetY = svgY - selectedElement.y + selectedElement.height/2;
                elementWasInteractedWith = true;
            }
        } else if (target.classList.contains('connection-line') || target.classList.contains('connection-label')) {
            deselectAll(); selectedElement = findConnectionById(target.dataset.connectionId);
            if (selectedElement) {
                selectedElement.selected = true; elementWasInteractedWith = true;
                redrawAll(); 
            }
        } else if (target.classList.contains('connection-handle')) {
            const connId = target.dataset.connectionId; const handleType = target.dataset.handleType;
            const conn = findConnectionById(connId);
            if (conn) {
                if (!conn.selected) { deselectAll(); conn.selected = true; selectedElement = conn; redrawAll(); }
                draggingConnectionHandle = { 
                    connection: conn, handleType: handleType,
                    originalFromNodeId: conn.fromNodeId, originalFromPoint: conn.fromPoint,
                    originalToNodeId: conn.toNodeId, originalToPoint: conn.toPoint
                };
                const fixedNode = (handleType === 'from') ? findNodeById(conn.toNodeId) : findNodeById(conn.fromNodeId);
                const fixedPointName = (handleType === 'from') ? conn.toPoint : conn.fromPoint;
                if (fixedNode && fixedPointName) {
                    const fixedAbsPoint = fixedNode.getConnectionPoints()[fixedPointName];
                    const p1ForPreview = (handleType === 'from') ? {x: svgX, y: svgY} : fixedAbsPoint;
                    const p2ForPreview = (handleType === 'from') ? fixedAbsPoint : {x: svgX, y: svgY};
                    const fromPtTypePreview = (handleType === 'from') ? 'bottom' : conn.fromPoint; 
                    const toPtTypePreview = (handleType === 'from') ? conn.toPoint : 'top'; 
                    connectionPreviewLine.setAttribute('d', getPathData(p1ForPreview, p2ForPreview, fromPtTypePreview, toPtTypePreview));
                    connectionPreviewLine.setAttribute('visibility', 'visible');
                    showAllConnectionPoints(true);
                }
                elementWasInteractedWith = true;
            }
        }

        if (!elementWasInteractedWith && !target.closest('.sidebar') && !target.closest('.header .controls') && !target.classList.contains('recent-color-swatch')) {
             if (connectionMode) { resetConnectionMode(); } 
             else { deselectAll(); }
        }
        updateSelectionVisuals(); updateEditPanel();
    });

    flowchartSVG.addEventListener('mousemove', (e) => {
        const { x: svgX, y: svgY } = getSVGCoordinates(e); 
        if (draggingNode && selectedElement && (selectedElement instanceof FlowchartNode)) {
            selectedElement.x = svgX - dragOffsetX + selectedElement.width/2;
            selectedElement.y = svgY - dragOffsetY + selectedElement.height/2;
            redrawAll();
        } else if (connectionMode && firstConnectionNode) {
            const p1 = firstConnectionNode.getConnectionPoints()[firstConnectionPointName];
            connectionPreviewLine.setAttribute('d', getPathData(p1, {x: svgX, y: svgY}, firstConnectionPointName, 'top'));
            highlightConnectionPoint(e.target);
        } else if (draggingConnectionHandle) {
            const conn = draggingConnectionHandle.connection;
            let p1, p2, fromPtType, toPtType;
            if (draggingConnectionHandle.handleType === 'from') {
                p1 = {x: svgX, y: svgY}; p2 = findNodeById(conn.toNodeId).getConnectionPoints()[conn.toPoint];
                fromPtType = 'bottom'; toPtType = conn.toPoint;
            } else {
                p1 = findNodeById(conn.fromNodeId).getConnectionPoints()[conn.fromPoint]; p2 = {x: svgX, y: svgY};
                fromPtType = conn.fromPoint; toPtType = 'top';
            }
            connectionPreviewLine.setAttribute('d', getPathData(p1, p2, fromPtType, toPtType));
            highlightConnectionPoint(e.target);
        }
    });
    
    function highlightConnectionPoint(target) {
        document.querySelectorAll('.connection-point.highlight').forEach(cp => cp.classList.remove('highlight'));
        if (target && target.classList.contains('connection-point') && (connectionMode || draggingConnectionHandle)) {
            target.classList.add('highlight');
        }
    }

    flowchartSVG.addEventListener('mouseup', (e) => {
        draggingNode = false;
        if (draggingConnectionHandle) {
            const conn = draggingConnectionHandle.connection;
            const handleType = draggingConnectionHandle.handleType;
            let success = false;
            if (e.target.classList.contains('connection-point')) {
                const targetNodeId = e.target.dataset.nodeId;
                const targetPointName = e.target.dataset.pointName;
                if (handleType === 'from') {
                    if (targetNodeId !== conn.toNodeId || (targetNodeId === conn.toNodeId && targetPointName !== conn.toPoint)) {
                        conn.fromNodeId = targetNodeId; conn.fromPoint = targetPointName; success = true;
                    }
                } else {
                    if (targetNodeId !== conn.fromNodeId || (targetNodeId === conn.fromNodeId && targetPointName !== conn.fromPoint)) {
                        conn.toNodeId = targetNodeId; conn.toPoint = targetPointName; success = true;
                    }
                }
            }
            if (!success) { 
                conn.fromNodeId = draggingConnectionHandle.originalFromNodeId; conn.fromPoint = draggingConnectionHandle.originalFromPoint;
                conn.toNodeId = draggingConnectionHandle.originalToNodeId; conn.toPoint = draggingConnectionHandle.originalToPoint;
            }
            draggingConnectionHandle = null; connectionPreviewLine.setAttribute('visibility', 'hidden');
            showAllConnectionPoints(false); redrawAll();
        }
    });

    flowchartSVG.addEventListener('dblclick', (e) => {
        if (selectedElement) {
            if (selectedElement instanceof FlowchartNode && panelNodeText.offsetParent !== null) panelNodeText.focus();
            else if (selectedElement instanceof FlowchartConnection && panelConnLabel.offsetParent !== null) panelConnLabel.focus();
        }
    });

    flowchartSVG.addEventListener('contextmenu', (e) => {
        e.preventDefault(); hideContextMenu();
        let targetElementInstance = null; const target = e.target;
        if (target.classList.contains('node-shape')) targetElementInstance = findNodeById(target.dataset.nodeId);
        else if (target.classList.contains('connection-line') || target.classList.contains('connection-label') || target.classList.contains('connection-handle')) {
             targetElementInstance = findConnectionById(target.dataset.connectionId);
        }
        if (targetElementInstance) {
            if (!targetElementInstance.selected) {
                deselectAll(); targetElementInstance.selected = true; selectedElement = targetElementInstance;
                updateSelectionVisuals(); updateEditPanel();
            }
            showContextMenu(e.clientX, e.clientY, targetElementInstance);
        } else if (connectionMode) { resetConnectionMode(); alert('Modo conexión cancelado.'); } 
          else { deselectAll(); updateEditPanel(); }
    });

    document.addEventListener('click', (e) => { 
        if (!contextMenu.contains(e.target) && !e.target.closest('#context-menu')) hideContextMenu();
        if (!flowchartSVG.contains(e.target) && !editPanel.contains(e.target) && !e.target.closest('.modal') && !e.target.closest('.header .controls button') && !e.target.classList.contains('recent-color-swatch')) {
            if (selectedElement && !connectionMode && !draggingConnectionHandle) { 
                deselectAll(); updateSelectionVisuals(); updateEditPanel();
            }
        }
    });
    
    function showContextMenu(x, y, elementInstance) { 
        contextMenu.innerHTML = ''; 
        if (elementInstance instanceof FlowchartNode) addContextMenuItem('Eliminar Nodo', () => deleteElement(elementInstance));
        else if (elementInstance instanceof FlowchartConnection) addContextMenuItem('Eliminar Conexión', () => deleteElement(elementInstance));
        if (contextMenu.children.length > 0) {
            contextMenu.style.left = `${x}px`; contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';
        }
    }
    function addContextMenuItem(label, action) {
        const item = document.createElement('div'); item.textContent = label;
        item.onclick = (e) => { e.stopPropagation(); action(); hideContextMenu(); };
        contextMenu.appendChild(item);
    }
    function hideContextMenu() { contextMenu.style.display = 'none'; }

    function updateEditPanel() {
        if (selectedElement instanceof FlowchartNode) {
            editPanelNodeContent.style.display = 'block'; editPanelConnContent.style.display = 'none';
            panelNodeText.value = selectedElement.text; panelNodeColor.value = selectedElement.color;
            panelNodeId.textContent = selectedElement.id; editPanel.classList.add('visible');
            renderRecentColors(); // Show recent colors
        } else if (selectedElement instanceof FlowchartConnection) {
            editPanelNodeContent.style.display = 'none'; editPanelConnContent.style.display = 'block';
            panelConnLabel.value = selectedElement.label; panelConnId.textContent = selectedElement.id;
            editPanel.classList.add('visible');
            recentColorsContainer.innerHTML = ''; // Clear recent colors for connections
        } else {
            editPanel.classList.remove('visible');
            editPanelNodeContent.style.display = 'none'; editPanelConnContent.style.display = 'none';
            recentColorsContainer.innerHTML = ''; // Clear recent colors when nothing is selected
        }
    }

    panelNodeText.addEventListener('input', (e) => { if (selectedElement instanceof FlowchartNode) { selectedElement.text = e.target.value; redrawAll(); }});
    panelNodeColor.addEventListener('input', (e) => { // 'input' for live update
        if (selectedElement instanceof FlowchartNode) {
            const newColor = e.target.value;
            selectedElement.color = newColor;
            addRecentColor(newColor); // Add to recents
            redrawAll(); // This will re-render recent colors if needed
        }
    });
    panelConnLabel.addEventListener('input', (e) => { if (selectedElement instanceof FlowchartConnection) { selectedElement.label = e.target.value; redrawAll(); }});
    panelDeleteBtn.addEventListener('click', () => { if (selectedElement) deleteElement(selectedElement); });

    function getSVGCoordinates(event) {
        const pt = flowchartSVG.createSVGPoint(); pt.x = event.clientX; pt.y = event.clientY;
        const ctm = flowchartSVG.getScreenCTM();
        if (ctm) return pt.matrixTransform(ctm.inverse());
        const rect = flowchartSVG.getBoundingClientRect();
        return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    }

    function deselectAll() {
        if (selectedElement) selectedElement.selected = false;
        nodes.forEach(n => n.selected = false); connections.forEach(c => c.selected = false);
        selectedElement = null;
    }

    function deleteElement(elementInstance) { 
        if (!elementInstance) elementInstance = selectedElement; if (!elementInstance) return;
        const toDelete = elementInstance; deselectAll(); 
        if (toDelete instanceof FlowchartNode) {
            nodes = nodes.filter(n => n.id !== toDelete.id);
            connections = connections.filter(c => c.fromNodeId !== toDelete.id && c.toNodeId !== toDelete.id);
        } else if (toDelete instanceof FlowchartConnection) {
            connections = connections.filter(c => c.id !== toDelete.id);
        }
        updateEditPanel(); redrawAll();
    }

    document.addEventListener('keydown', (e) => {
        const activeEl = document.activeElement;
        const isInputFocused = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA';
        if ((e.key === 'Delete' || e.key === 'Backspace') && !isInputFocused) {
            if (selectedElement) { e.preventDefault(); deleteElement(selectedElement); }
        }
        if (e.key === 'Escape') {
            if (connectionMode) { resetConnectionMode(); alert('Modo conexión cancelado.'); }
            if (draggingConnectionHandle) {
                const conn = draggingConnectionHandle.connection;
                conn.fromNodeId = draggingConnectionHandle.originalFromNodeId; conn.fromPoint = draggingConnectionHandle.originalFromPoint;
                conn.toNodeId = draggingConnectionHandle.originalToNodeId; conn.toPoint = draggingConnectionHandle.originalToPoint;
                draggingConnectionHandle = null; connectionPreviewLine.setAttribute('visibility', 'hidden');
                showAllConnectionPoints(false); redrawAll();
            }
            hideContextMenu(); document.querySelectorAll('.modal.visible').forEach(m => m.classList.remove('visible'));
            if (selectedElement) { deselectAll(); updateSelectionVisuals(); updateEditPanel(); }
        }
    });

    document.getElementById('add-connection-btn').addEventListener('click', () => {
        connectionMode = true; firstConnectionNode = null; firstConnectionPointName = null;
        connectionPreviewLine.setAttribute('visibility', 'hidden');
        showAllConnectionPoints(true); deselectAll(); 
        updateSelectionVisuals(); updateEditPanel();
        alert('Modo Conexión Activado: Haz clic en un punto de conexión de origen, luego en uno de destino. Click derecho o ESC para cancelar.');
    });

    function showAllConnectionPoints(visible) {
        document.querySelectorAll('.connection-point').forEach(cp => {
            cp.classList.toggle('visible', visible);
            if (!visible) cp.classList.remove('highlight');
        });
    }

    function resetConnectionMode() {
        connectionMode = false; firstConnectionNode = null; firstConnectionPointName = null;
        connectionPreviewLine.setAttribute('visibility', 'hidden');
        showAllConnectionPoints(false); redrawAll(); 
    }

    document.getElementById('clear-btn').addEventListener('click', () => {
        if (confirm('¿Estás seguro de que quieres limpiar todo el diagrama?')) {
            nodes = []; connections = []; nextNodeIdCounter = 1; selectedElement = null;
            resetConnectionMode(); draggingConnectionHandle = null; 
            redrawAll();
        }
    });

    document.getElementById('export-svg-btn').addEventListener('click', () => {
        if (nodes.length === 0) { alert("No hay nada que exportar."); return; }
        const svgClone = flowchartSVG.cloneNode(true);
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        if (nodes.length > 0) {
            nodes.forEach(node => {
                minX = Math.min(minX, node.x - node.width / 2); maxX = Math.max(maxX, node.x + node.width / 2);
                minY = Math.min(minY, node.y - node.height / 2); maxY = Math.max(maxY, node.y + node.height / 2);
            });
        } else { minX = 0; minY = 0; maxX = 200; maxY = 150;}
        minX = isFinite(minX) ? minX : 0; minY = isFinite(minY) ? minY : 0;
        maxX = isFinite(maxX) ? maxX : flowchartSVG.parentElement.clientWidth || 2000;
        maxY = isFinite(maxY) ? maxY : flowchartSVG.parentElement.clientHeight || 1500;
        const exportContentWidth = Math.max(0, maxX - minX); const exportContentHeight = Math.max(0, maxY - minY);
        const exportWidth = exportContentWidth + SVG_PADDING; const exportHeight = exportContentHeight + SVG_PADDING;
        const viewBoxMinX = minX - SVG_PADDING / 2; const viewBoxMinY = minY - SVG_PADDING / 2;
        svgClone.setAttribute('width', exportWidth); svgClone.setAttribute('height', exportHeight);
        svgClone.setAttribute('viewBox', `${viewBoxMinX} ${viewBoxMinY} ${exportWidth} ${exportHeight}`);
        const previewLineClone = svgClone.querySelector('#connection-preview-line');
        if (previewLineClone) previewLineClone.remove();
        svgClone.querySelectorAll('.connection-point, .connection-handle').forEach(el => el.remove());
        svgClone.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        const styleElement = document.createElementNS(SVG_NS, 'style');
        styleElement.textContent = `
            .node-shape { stroke-width: 1.5; stroke: ${getCssVariable('--node-border')}; }
            .node-text { font-family: ${getCssVariable('--font-family')}; font-size: 12px; text-anchor: middle; dominant-baseline: middle; pointer-events: none; user-select: none; }
            .connection-line { stroke-width: 2; fill: none; stroke: ${getCssVariable('--connection-color')};}
            .connection-label { font-family: ${getCssVariable('--font-family')}; font-size: 10px; fill: blue; text-anchor: middle; user-select: none;}
            #arrowhead polygon { fill: ${getCssVariable('--connection-color')}; }
        `;
        const defs = svgClone.querySelector('defs');
        if (defs) defs.insertAdjacentElement('afterend', styleElement);
        else svgClone.insertBefore(styleElement, svgClone.firstChild);
        const serializer = new XMLSerializer(); let svgString = serializer.serializeToString(svgClone);
        if (!svgString.startsWith('<?xml')) svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
        if (svgClone.getAttribute('xmlns') !== SVG_NS && !svgString.includes(`xmlns="${SVG_NS}"`)) {
            svgString = svgString.replace(/<svg/i, `<svg xmlns="${SVG_NS}"`);
        }
        const blob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
        const url = URL.createObjectURL(blob); const a = document.createElement('a');
        a.href = url; a.download = 'flowchart.svg'; document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url); alert('SVG exportado.');
    });

    document.getElementById('generate-ai-btn').addEventListener('click', () => {
        if (!checkApiKey()) return;
        aiPromptModal.classList.add('visible');
        document.getElementById('ai-prompt-input').value = '';
        document.getElementById('ai-loader').style.display = 'none';
    });
    document.getElementById('cancel-ai-prompt-btn').addEventListener('click', () => aiPromptModal.classList.remove('visible'));
    document.getElementById('submit-ai-prompt-btn').addEventListener('click', async () => {
        const promptText = document.getElementById('ai-prompt-input').value.trim();
        if (!promptText) { alert('Por favor, introduce una descripción para el diagrama.'); return; }
        if (!checkApiKey()) return;
        document.getElementById('ai-loader').style.display = 'block';
        document.getElementById('submit-ai-prompt-btn').disabled = true;
        const systemPrompt = `
        Eres un asistente que convierte descripciones de procesos en diagramas de flujo JSON.
        INSTRUCCIONES IMPORTANTES:
        1. Responde ÚNICAMENTE con un JSON válido, sin texto adicional antes o después del JSON.
        2. No uses comillas dobles dentro de los valores "text" o "label" de los nodos/conexiones. Usa comillas simples si es necesario, o evítalas.
        3. Los textos deben ser cortos (máximo 3-4 palabras).
        4. Colores DEBEN ser hexadecimales (ej: "#RRGGBB"). Sugiere colores semánticos (start: verde claro, end: rojo claro, process: azul claro, decision: amarillo claro) o usa el por defecto "#add8e6".
        5. Usa coordenadas X entre 100 y 1800, y Y entre 100 y 1300.
        6. Separa los nodos por al menos 150-200 píxeles para evitar solapamientos.
        7. Asegúrate de que los IDs de los nodos sean únicos y simples (ej: "node1", "decisionA").
        8. Para los puntos de conexión ('from_point', 'to_point'), usa solo 'top', 'bottom', 'left', 'right'.

        ESTRUCTURA EXACTA DEL JSON DE SALIDA:
        {
            "nodes": [
                {"id": "start1", "text": "Inicio", "type": "start", "x": 400, "y": 100, "color": "#90EE90"},
                {"id": "process1", "text": "Accion 1", "type": "process", "x": 400, "y": 250, "color": "#87CEEB"},
                {"id": "decision1", "text": "Condicion?", "type": "decision", "x": 400, "y": 400, "color": "#FFE4B5"},
                {"id": "process2", "text": "Accion Si", "type": "process", "x": 250, "y": 550, "color": "#87CEEB"},
                {"id": "process3", "text": "Accion No", "type": "process", "x": 550, "y": 550, "color": "#87CEEB"},
                {"id": "end1", "text": "Fin", "type": "end", "x": 400, "y": 700, "color": "#FFB6C1"}
            ],
            "connections": [
                {"from": "start1", "to": "process1", "from_point": "bottom", "to_point": "top", "label": ""},
                {"from": "process1", "to": "decision1", "from_point": "bottom", "to_point": "top", "label": ""},
                {"from": "decision1", "to": "process2", "from_point": "left", "to_point": "top", "label": "Si"},
                {"from": "decision1", "to": "process3", "from_point": "right", "to_point": "top", "label": "No"},
                {"from": "process2", "to": "end1", "from_point": "bottom", "to_point": "top", "label": ""},
                {"from": "process3", "to": "end1", "from_point": "bottom", "to_point": "top", "label": ""}
            ]
        }
        TIPOS DE NODOS PERMITIDOS: start, end, process, decision.
        PUNTOS DE CONEXIÓN PERMITIDOS: top, bottom, left, right.
        El JSON debe empezar con { y terminar con }. No incluyas ningún otro texto fuera del bloque JSON.
        `;
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
        try {
            const response = await fetch(apiUrl, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: systemPrompt + "\n\nDescripción del proceso: " + promptText }] }] })
            });
            if (!response.ok) { const errorData = await response.json(); throw new Error(`Error de API: ${response.status} - ${errorData.error?.message || 'Error desconocido'}`);}
            const data = await response.json(); let aiResponseText = "";
            if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.text) aiResponseText = data.candidates[0].content.parts[0].text;
            else throw new Error("Respuesta de la IA no contiene el texto esperado.");
            aiResponseText = aiResponseText.replace(/^```json\s*/, '').replace(/\s*```$/, '').trim();
            const firstBrace = aiResponseText.indexOf('{'); const lastBrace = aiResponseText.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) aiResponseText = aiResponseText.substring(firstBrace, lastBrace + 1);
            else throw new Error("No se pudo extraer un bloque JSON válido de la respuesta de la IA. Respuesta: " + aiResponseText.substring(0, 200) + "...");
            const diagramData = JSON.parse(aiResponseText);
            createDiagramFromData(diagramData); aiPromptModal.classList.remove('visible');
            alert('Diagrama generado exitosamente!');
        } catch (error) {
            console.error('Error generando diagrama con IA:', error);
            alert(`Error al generar diagrama: ${error.message}. Revisa la consola para más detalles.\nAsegúrate que tu API Key sea correcta y tenga permisos para Gemini.`);
        } finally {
            document.getElementById('ai-loader').style.display = 'none';
            document.getElementById('submit-ai-prompt-btn').disabled = false;
        }
    });

    function createDiagramFromData(data) {
        nodes = []; connections = []; nextNodeIdCounter = 1; 
        const defaultNodeColors = { "start": "#90EE90", "end": "#FFB6C1", "process": "#87CEEB", "decision": "#FFE4B5" };
        if (data.nodes) {
            data.nodes.forEach(nodeData => {
                const id = nodeData.id || `node${nextNodeIdCounter++}`;
                const color = (nodeData.color && nodeData.color.match(/^#[0-9a-fA-F]{6}$/)) ? nodeData.color : (defaultNodeColors[nodeData.type] || '#add8e6');
                const node = new FlowchartNode( id, nodeData.text, nodeData.type,
                    parseInt(nodeData.x) || (Math.random() * 1500 + 100), 
                    parseInt(nodeData.y) || (Math.random() * 1000 + 100), 
                    color
                );
                nodes.push(node);
                addRecentColor(color); // Add AI suggested/default color to recents
                const numericIdPart = id.match(/\d+$/);
                if (numericIdPart) { const numericId = parseInt(numericIdPart[0]); if (numericId >= nextNodeIdCounter) nextNodeIdCounter = numericId + 1; }
            });
        }
        if (data.connections) {
            data.connections.forEach(connData => {
                const fromNode = findNodeById(connData.from); const toNode = findNodeById(connData.to);
                if (fromNode && toNode) connections.push(new FlowchartConnection( null, connData.from, connData.to, connData.from_point || 'bottom', connData.to_point || 'top', connData.label || '' ));
                else console.warn("Conexión inválida de IA, nodo no encontrado:", connData);
            });
        }
        redrawAll(); 
    }
    
    renderRecentColors(); // Initial render of stored recent colors
    redrawAll();
    checkApiKey(); 

</script>
</body>
</html>
